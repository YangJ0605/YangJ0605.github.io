<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面试 on mo白的博客</title>
    <link>https://yangj0605.github.io/tags/%E9%9D%A2%E8%AF%95/</link>
    <description>Recent content in 面试 on mo白的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 21 Oct 2019 21:21:18 +0800</lastBuildDate>
    
	<atom:link href="https://yangj0605.github.io/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js的设计模式</title>
      <link>https://yangj0605.github.io/post/js%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 21 Oct 2019 21:21:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/js%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>一开始都没听说过这个名词，后面看了几篇文章才算理解，写一篇记录以防忘记 一、观察者模式（Observer） 观察者模式指的是一个对象（Subje</description>
    </item>
    
    <item>
      <title>ES6之class与继承</title>
      <link>https://yangj0605.github.io/post/es6%E4%B9%8Bclass%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 20 Oct 2019 22:11:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/es6%E4%B9%8Bclass%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>首先来看看JS中继承的两种写法 ES5 写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function Human(name){ this.name = name } Human.prototype.run = function(){ console.log(&amp;#34;我叫&amp;#</description>
    </item>
    
    <item>
      <title>数组的一些方法</title>
      <link>https://yangj0605.github.io/post/%E6%95%B0%E7%BB%84%E7%9A%84foreachmapreduce/</link>
      <pubDate>Sat, 19 Oct 2019 21:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E6%95%B0%E7%BB%84%E7%9A%84foreachmapreduce/</guid>
      <description>forEach() 方法对数组的每个元素执行一次提供的函数。 1 2 3 4 5 var array1 = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]; array1.forEach(function(element) { console.log(element); }); 原理: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function forEach(array,x){ for(let i=0;i&amp;lt;array.length;i++){ x(array[i],i) } } //调用</description>
    </item>
    
    <item>
      <title>es6之set</title>
      <link>https://yangj0605.github.io/post/es6%E4%B9%8Bset/</link>
      <pubDate>Fri, 18 Oct 2019 22:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/es6%E4%B9%8Bset/</guid>
      <description>set是ES6中新增的类型，和数组类似，唯一不同在于该类型不会有重复的数据，一般常用来对数据进行去重操作。 一、声明 let set = new Set();即创建</description>
    </item>
    
    <item>
      <title>标签模板</title>
      <link>https://yangj0605.github.io/post/%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 17 Oct 2019 23:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF/</guid>
      <description>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，紧跟在后面的模板字符串就是它的参数。 1 2 3 4 5 6 7 8 var a =5 var b=10 xx `Hello ${a+b} world</description>
    </item>
    
    <item>
      <title>JavaScript经典题目</title>
      <link>https://yangj0605.github.io/post/javascript%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Thu, 17 Oct 2019 21:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/javascript%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</guid>
      <description>记录一些做错的题 1 2 3 4 5 6 7 8 9 10 const shape = { radius: 10, diameter() { return this.radius * 2; }, perimeter: () =&amp;gt; 2 * Math.PI * this.radius }; shape.diameter(); shape.perimeter(); A: 20 and 62.83185307179586 B: 20 and NaN C: 20 and 63 D: NaN and 63 请注意，diameter</description>
    </item>
    
    <item>
      <title>canvas使用</title>
      <link>https://yangj0605.github.io/post/canvas/</link>
      <pubDate>Tue, 15 Oct 2019 22:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/canvas/</guid>
      <description>canvas 标签 &amp;lt;canvas width=&amp;quot;600&amp;quot; height=&amp;quot;400&amp;quot; id=&amp;quot;canvas&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt; 不给宽高的话默认是300+150 怎么用 1 2 3 4 //拿到canvas var canvas = document.getElementById(&amp;#34;canvas&amp;#34;); //创建画图工具 var context = canvas.getContext(&amp;#34;2d&amp;#34;); 相关的api及用法 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>按值传递</title>
      <link>https://yangj0605.github.io/post/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 12 Oct 2019 21:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>定义 在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递</description>
    </item>
    
    <item>
      <title>闭包初识</title>
      <link>https://yangj0605.github.io/post/%E9%97%AD%E5%8C%85%E5%88%9D%E8%AF%86/</link>
      <pubDate>Sat, 12 Oct 2019 21:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E9%97%AD%E5%8C%85%E5%88%9D%E8%AF%86/</guid>
      <description>定义 MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 举个例子： 1 2 3 4 5 6 7 var a = 1; function foo() { console.log(a); } foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函</description>
    </item>
    
    <item>
      <title>变量对象</title>
      <link>https://yangj0605.github.io/post/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 12 Oct 2019 00:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</guid>
      <description>变量对象 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 全局上下文 1 2 3 4 5 var a = 1; console.log(window.a); this.window.b = 2; console.log(this.b); 全局上下文中的变</description>
    </item>
    
    <item>
      <title>执行上下文栈</title>
      <link>https://yangj0605.github.io/post/%E6%89%A7%E8%A1%8C%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</link>
      <pubDate>Fri, 11 Oct 2019 20:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E6%89%A7%E8%A1%8C%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</guid>
      <description>变量提升 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var foo = function () { console.log(&amp;#39;foo1&amp;#39;); } foo(); // foo1 var foo = function () { console.log(&amp;#39;foo2&amp;#39;); } foo(); // foo2 函数声明提升 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function foo() { console.log(&amp;#39;foo1&amp;#39;); } foo(); // foo2</description>
    </item>
    
    <item>
      <title>作用域</title>
      <link>https://yangj0605.github.io/post/%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Thu, 10 Oct 2019 23:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>作用域了解 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域 因为 JavaScript 采用的是词法作用域，函数的作用域在</description>
    </item>
    
    <item>
      <title>原型与原型链</title>
      <link>https://yangj0605.github.io/post/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 10 Oct 2019 20:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>构造函数创建对象 1 2 3 4 5 6 7 8 9 10 function Person() { } var person = new Person(); console.log(person.__proto__ === Person.prototype) // true console.log(Person.prototype.constructor === Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 原型链 1 2</description>
    </item>
    
    <item>
      <title>web性能优化</title>
      <link>https://yangj0605.github.io/post/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 30 Sep 2019 20:15:18 +0800</pubDate>
      
      <guid>https://yangj0605.github.io/post/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>常见的一些web性能优化套路 1.减少DNS查询 2.TCP连接复用（keep alive）、HTTP2.0 多复用 3.发起请求的时候减少cooki</description>
    </item>
    
  </channel>
</rss>